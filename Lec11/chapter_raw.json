{
    "review": "<h2><strong>11.1 Structure Variables</strong></h2><h3><strong>Declaring Structure Variables</strong></h3><ul><li><p>Compared to an array, elements (members) of a structure:</p><ul><li><p>are not required to have the same type.</p></li><li><p>are specified by names, not positions.</p></li></ul></li><li><p>Members of a structure are stored in memory <strong>in the order</strong> in which <strong>they’re declared</strong>.</p></li></ul><h3><strong>Initializing Structure Variables</strong></h3><ul><li><p>A structure declaration may include an initializer:</p><pre><code>struct {\n    int number;\n    char name[NAME_LEN+1];\n    int on_hand;\n} part1 = {528, \"Disk drive\", 10},\n  part2 = {914, \"Printer cable\", 5};\n</code></pre></li><li><p>In a designated initializer, each value would be labeled by the name of the member that it initializes:</p><pre><code>{.number = 528, .name = \"Disk drive\", .on_hand = 10}\n</code></pre></li><li><p>An initializer <strong>can have fewer members</strong> than the structure it’s initializing.</p></li><li><p>Any members that the initializer fails to account for are <strong>set to zero</strong></p></li><li><p>Not all values listed in a designated initializer need be prefixed by a designator.</p><ul><li><p>The compiler assumes that “Disk drive” initializes the member that follows number in the structure.</p><pre><code>{.number = 528, \"Disk drive\", .on_hand = 10}\n</code></pre></li></ul></li></ul><h3><strong>Operations on Structures</strong></h3><ul><li><p>To access a member of a structure, we use the period (<code>.</code>) operator:</p><pre><code>printf(\"Part number: %d\\n\", part1.number);\npart1.number = 258;\n</code></pre></li><li><p>Arrays can’t be copied using the <code>=</code> operator, but a structure can be copied.</p><pre><code>struct { int a[10]; } a1, a2;\na1 = a2;\n</code></pre></li></ul><h2><strong>11.2 Structure Types</strong></h2><ul><li><p>Ways to name a structure:</p><ul><li><p>Declare a <strong>structure tag</strong></p><pre><code>struct part {\n    int number;\n    char name[NAME_LEN+1];\n    int on_hand;\n};\nstruct part part1, part2;\n</code></pre></li><li><p>Use <strong>typedef</strong> to define a type name</p><pre><code>typedef struct {\n    int number;\n    char name[NAME_LEN+1];\n    int on_hand;\n} Part;\nPart part1, part2;\n</code></pre></li></ul></li><li><p>Functions may have structures as arguments (pass-by-value) and return values (return-by-value).</p><pre><code>struct part fun(struct part p)\n{\n    return p;\n}\n</code></pre></li><li><p>A compound literal can be passed as a parameter, returned by a function, or assigned to a variable.</p><pre><code>print_part((struct part) {528, \"Disk drive\", 10});\nprint_part((struct part) {.on_hand = 10,\n                          .name = \"Disk drive\",\n                          .number = 528});\npart1 = (struct part) {528, \"Disk drive\", 10};\n</code></pre></li></ul><h2><strong>11.3 Nested Arrays and Structures</strong></h2><ul><li><p>Structures and arrays can be combined without restriction</p><ul><li><p>Nested Structure</p><pre><code>struct student {\n    struct person_name name;\n    …\n} student1, student2;\nstudent1.name = tmp_name;\n</code></pre></li><li><p>Array of Structure</p><pre><code>struct part inventory[100];\ninventory[i].number = 883;</code></pre></li></ul></li></ul>",
    "videoUrl": "https://www.youtube.com/embed/9jnJvcSGJ5E,https://www.youtube.com/embed/wBsWC1RHnQM,https://www.youtube.com/embed/oD8ENJGUmDQ",
    "makeUpTime": "2022-12-14T16:00:00.000Z",
    "notification": {
        "makeUpTime": "_86ZrHie7LbcP_BDlddv"
    },
    "startTime": "2022-11-30T16:00:00.000Z",
    "dueTime": "2022-12-21T16:00:00.000Z",
    "sections": [],
    "type": "Homework",
    "index": "Lec11",
    "title": "Structures Unions and Enumerations"
}