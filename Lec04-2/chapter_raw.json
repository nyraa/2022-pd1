{
    "review": "<h2>4.4 Type Conversion</h2><ol><li><p> To perform an <strong>arithmetic operation</strong>, the operands must usually be of <strong>the same size</strong> and be <strong>stored in the same way</strong>.</p></li><li><p>When operands of different <strong>types are mixed</strong> in expressions, the <strong>C compiler</strong> may have to generate instructions that <strong>change the types of some operands</strong>.</p></li><li><p>Because the compiler handles these conversions automatically, without the programmer’s involvement, they’re known as <strong>implicit conversions</strong>.</p></li><li><p>Implicit conversions are performed in the following situation:</p><ul><li><p>The operands in an arithmetic or logical expression <strong>don’t have the same type</strong>.</p></li><li><p>The type of the expression on the <strong>right side</strong> of an assignment <strong>doesn’t match</strong> the type of the variable on the <strong>left side</strong>.</p></li><li><p>The type of the expression in a return statement doesn’t match the function’s return type. (Lec 5)</p></li><li><p>The type of the expression in a return statement doesn’t match the function’s return type. (Lec 5)</p></li></ul></li></ol><h3>The Usual Arithmetic Conversions</h3><ol><li><p>Convert operands to the <strong>narrowest</strong> type that will safely accommodate both values.</p></li><li><p>The type of <strong>either</strong> operand is a floating type:</p><p>(other type) -&gt; <code>float</code> -&gt; <code>dobule</code> -&gt; <code>long double</code></p></li><li><p>Neither operand type is a floating type. Integral promotion:</p></li></ol><p>    <code>int</code> -&gt; <code>unsigned int</code> -&gt; <code>long int</code> -&gt; <code>unsigned long int</code></p><ol start=\"4\"><li><p>When a <code>signed</code> operand is combined with an <code>unsigned</code> operand, the signed operand is <strong>converted to an unsigned value</strong>.</p></li></ol><h3>Conversion During Assignment</h3><ol><li><p>The usual arithmetic conversions don’t apply to assignment.</p></li><li><p>The expression on the <strong>right side</strong> of the assignment is <strong>converted to the type of the variable on the left side</strong>.</p></li><li><p> Assigning a <strong>floating-point number to an integer</strong> variable <strong>drops</strong> the fractional part of the number.</p></li></ol><h3>Casting</h3><ol><li><p>Cast expressions also let us <strong>force the compiler to perform conversions</strong>.</p></li><li><p>A cast expression has the form:</p></li></ol><p>    <code>( type-name ) expression</code></p><h2>4.5 Type Definitions</h2><h3>Advantages of Type Definitions</h3><ol><li><p>Type definitions can <strong>make a program more understandable</strong>.</p></li><li><p>Type definitions are an important tool for writing <strong>portable programs</strong>.</p><ul><li><p>Types may have different ranges on different machines.</p></li></ul></li></ol><h3>Type Definitions and Portability</h3><ol><li><p>The <strong>C library</strong> itself uses typedef to create names for types that can vary from one C implementation to another.</p><ul><li><p>these types often have names that end with <code>_t</code>.</p></li></ul></li><li><p>The <code>&lt;stdint.h&gt;</code> header uses typedef to define names for integer types with a <strong>particular number of bits</strong>.</p></li></ol><h3>The sizeof Operator</h3><ol><li><p><code>sizeof</code> operator returns <strong>required bytes</strong> to store a value.</p></li><li><p>The sizeof operator can be applied to <strong>constants</strong>, <strong>variables</strong>, and <strong>expressions</strong> in general.</p></li><li><p>When applied to an <strong>expression</strong>, sizeof doesn’t require parentheses.</p><ul><li><p>We could write <code>sizeof i</code> instead of <code>sizeof(i)</code>.</p></li><li><p>Parentheses may be needed anyway because of operator precedence.</p></li></ul></li><li><p>The type of a sizeof expression is an <strong>implementation-defined</strong> type, named <code>size_t</code>.</p></li><li><p>Print returned value of sizeof:</p><ul><li><p>C89: <code>printf(\"%lu\\n\", (unsigned long) sizeof(int));</code></p></li><li><p>C99: <code>printf(\"%zu\\n\", sizeof(int));</code></p></li></ul></li></ol><h2>4.6 Bitwise Operation</h2><ol><li><p>C provides <strong>six bitwise operators</strong>, which operate on integer data at the <strong>bit level</strong>.</p><ul><li><p><code>&amp;</code> : AND</p></li><li><p><code>|</code> : OR</p></li><li><p><code>~</code> : NOT</p></li><li><p><code>&lt;&lt;</code> : Left shift</p></li><li><p><code>&gt;&gt;</code> : Right shift</p></li><li><p><code>^</code> : XOR</p></li></ul></li></ol><h3>Bitwise Shift Operators</h3><ol><li><p>The bitwise shift operators shift the bits in an integer to the left or right.</p><ul><li><p><code>&lt;&lt;</code> : Left shift</p></li><li><p><code>&gt;&gt;</code> : Right shift</p></li></ul></li><li><p>The operands for <code>&lt;&lt;</code> and <code>&gt;&gt;</code> may be of <strong>any integer type</strong> (including char).</p></li></ol><ol start=\"3\"><li><p>The value of <code>i &lt;&lt; j</code> is the result when the bits in <code>i</code> are <strong>shifted left</strong> by <code>j</code> places.</p><ul><li><p>For each bit that is <strong>shifted off</strong> the left end of <code>i</code>, a <strong>zero bit enters at the right</strong>.</p></li></ul></li><li><p>The value of <code>i &gt;&gt; j</code> is the result when <code>i</code> is <strong>shifted right</strong> by <code>j</code> places.</p><ul><li><p>If <code>i</code> is of an <strong>unsigned type</strong> or if the value of <code>i</code> is <strong>nonnegative</strong>, <strong>zeros</strong> are added at the left as needed</p></li><li><p>If <code>i</code> is <strong>negative</strong>, the result is <strong>implementation-defined</strong>.</p></li></ul></li><li><p>To modify a variable by shifting its bits, use the compound assignment operators <code>&lt;&lt;=</code> and <code>&gt;&gt;=</code>.</p></li></ol><h3>Bitwise Complement, And, Exclusive Or, and Inclusive Or</h3><p><img src=\"https://i.imgur.com/Ty6NUSY.png\" alt=\"bitwise\"></p><ol><li><p>The <code>~</code> operator is <strong>unary</strong>, and the other operators are <strong>binary</strong>.</p></li><li><p>Each of the <code>~</code>, <code>&amp;</code>, <code>^</code>, and <code>|</code> operators has a different precedence:</p><p>(high) <code>~</code> -&gt; <code>&amp;</code> -&gt; <code>^</code> -&gt; <code>|</code> (low)</p></li></ol><h3>Using the Bitwise Operators to Access Bits </h3><ol><li><p>The bitwise operators can be used to <strong>extract or modify</strong> data stored in a <strong>small number of bits</strong>.</p></li><li><p>Common single-bit operations:</p><ul><li><p>Setting a bit</p></li><li><p>Clearing a bit</p></li><li><p>Testing a bit</p></li></ul></li><li><p>Example of <strong>setting</strong> bit 4 of <code>i</code>:</p><pre><code>i  = 0x0000; /* i is now 0000 0000 0000 0000 */\ni |= 0x0010; /* i is now 0000 0000 0001 0000 */</code></pre></li><li><p>Example of <strong>clearing</strong> bit 4 of <code>i</code>:</p><pre><code>i  =  0x00ff;  /* i is now 0000 0000 1111 1111 */\ni &amp;= ~0x0010;  /* i is now 0000 0000 1110 1111 */</code></pre></li><li><p>Example of <strong>testing</strong> whether bit 4 of <code>i</code> is set:</p><pre><code>if (i &amp; 0x0010)</code></pre></li></ol><h3>Using the Bitwise Operators to Access BitFields</h3><ol><li><p>Common bit-field operations:</p><ul><li><p>Modifying a bit-field</p></li><li><p>Retrieving a bit-field</p></li></ul></li><li><p>Modifying a bit-field requires two operations:</p><ul><li><p>A <code>bitwise AND</code> (to <strong>clear</strong> the bit-field)</p></li><li><p>A <code>bitwise OR</code> (to <strong>store</strong> new bits in the bit-field)</p></li></ul></li><li><p>Retrieving a bit-field. </p><ul><li><p>Fetching a bit-field <strong>at the right end of a number</strong> (in the least significant bits) is easy.</p><pre><code>j = i &amp; 0x0007; /* retrieves bits 0-2 */</code></pre></li><li><p>If the bit-field <strong>isn’t at the right end of i</strong>, we can first <strong>shift</strong> the bit-field to the end before extracting the field using the <code>&amp;</code> operator.</p><pre><code>/* retrieves bits 4-6 */\n/* i      : ???? ???? ?XXX ???? */\n/* i &gt;&gt; 4 : ???? ???? ???? ?XXX */\n\nj = (i &gt;&gt; 4) &amp; 0x0007;</code></pre></li></ul></li></ol>",
    "videoUrl": "https://www.youtube.com/embed/2iPqz5IgEis,https://www.youtube.com/embed/HQhyywYpNEE,https://www.youtube.com/embed/L8jPv5QTiDE",
    "makeUpTime": "2022-10-26T16:00:00.000Z",
    "notification": {
        "makeUpTime": "QEfp0wN4IxiqFPeqsXcK"
    },
    "startTime": "2022-10-12T16:00:00.000Z",
    "dueTime": "2022-11-02T16:00:00.000Z",
    "sections": [],
    "type": "Homework",
    "index": "Lec04-2",
    "title": "Data Types (part 2)"
}