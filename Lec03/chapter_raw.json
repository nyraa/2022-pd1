{
    "review": "<h1>3.1 Logical Expression</h1><h2>Relational and Equality Operators</h2><ol><li><p> Used to test the value of an expression.</p></li><li><p>Four relational operators:</p><ul><li><p><code>&lt;</code> less than</p></li><li><p><code>&gt;</code> greater than</p></li><li><p><code>&lt;=</code> less than or equal to</p></li><li><p><code>&gt;=</code> greater than or equal to</p></li></ul></li><li><p>Two equality operators:</p><ul><li><p><code>==</code> equal to</p></li><li><p><code>!=</code> not equal to</p></li></ul></li><li><p>Produce <strong>0 (false)</strong> or <strong>1 (true)</strong> when used in expressions.</p></li><li><p>Can be used to compare integers and floating-point numbers.</p></li><li><p>Mixed types are allowed.</p></li><li><p>Left associative.</p></li><li><p>Have lower precedence than the arithmetic operators: <code>i + j &lt; k - l</code> becomes <code>(i + j) &lt; (k - l)</code></p></li></ol><h2>Logical Operators</h2><ol><li><p>Used to build more complicated logical expressions.</p></li><li><p>Three logical operators:</p><ul><li><p><code>!</code> logical negation</p></li><li><p><code>&amp;&amp;</code> logical and</p></li><li><p><code>||</code> logical or</p></li></ul></li><li><p>The <code>!</code> operator is unary, while <code>&amp;&amp;</code> and <code>||</code> are binary.</p></li><li><p>Produce <strong>0</strong> or <strong>1</strong> as result.</p></li><li><p>Treat <strong>nonzero operand</strong> (1, 2, -100, etc) as a <strong>true</strong> value.</p></li><li><p>The behavior:</p><ul><li><p><code>!expr</code> has the value 1 if <code>expr</code> is 0.</p></li><li><p><code>expr1 &amp;&amp; expr2</code> has the value 1 only when both <code>expr1</code> and <code>expr2</code> are <strong>true</strong> value.</p></li><li><p><code>expr1 || expr2</code> has the value 1 if either one of them is true, or both of them are true.</p></li><li><p>Both <code>&amp;&amp;</code> and <code>||</code> perform <strong>short-circuit</strong> evaluation: the second expression (<code>expr2</code>) is omitted if the result can be deduced by the first expression (<code>expr1</code>).</p></li></ul></li><li><p>The precedence of <code>!</code> is equal to unary <code>+</code> and <code>-</code>.</p></li><li><p>The precedence of both <code>&amp;&amp;</code> and <code>||</code> are lower than <strong>relational operators</strong> and <strong>equality operators</strong>.</p></li><li><p><code>!</code> is right associative while <code>&amp;&amp;</code> and <code>||</code> are left associative.</p></li></ol><h1>3.2 The <code>if</code> statement</h1><h2><code>if-else</code> statement</h2><p>The <code>if</code> statement has the following form:</p><pre><code>if ( expression )\n    statement1\nelse\n    statement2</code></pre><p>where <code>else</code> and <code>statement2</code> could be omitted if they are no needed.</p><ol><li><p>The <code>statement1</code> is executed if <code>expression</code> is evaluated and has a <strong>true</strong> value.</p></li><li><p>The <code>statement2</code> (if presented) is executed if <code>expression</code> has a <strong>false</strong> value.</p></li><li><p>Make sure use <code>==</code> (equality) and <code>=</code> (assignment) properly.</p></li><li><p>Test series of conditions with cascaded <code>if</code> statements:</p></li></ol><pre><code>if ( expr1 )\n    statement1\nelse if ( expr2 )\n    statement2\nelse\n    statement3</code></pre><ol start=\"5\"><li><p>The <code>else</code> belongs to the nearest <code>if</code> that has not paired with an <code>else</code>, which may cause <strong>dangling else</strong> problem.</p></li><li><p>Use braces properly tells the compiler which <code>if</code> the <code>else</code> belongs to.</p></li></ol><pre><code>if (expr1)\n    if (expr2)\n        statement1\n    else\n        statement2</code></pre><p>    vs.</p><pre><code>if (expr1) {\n    if (expr2) {\n        statement1\n    }\n} else {\n    statement2\n}</code></pre><h2>Compound Statement</h2><p>The compound statement has following form:</p><pre><code>{ statements }</code></pre><ol><li><p>Enclose several statements with braces (<code>{}</code>) to make the compiler treat them as a single statement.</p></li><li><p>Inner statements still end with a semicolon (<code>;</code>).</p></li><li><p>Compound statement itself does not end with a semicolon.</p></li></ol><h2>Conditional Expressions</h2><pre><code>expr1 ? expr2 : expr3</code></pre><ol><li><p>Produce one of two values depends on the value of a condition.</p></li><li><p>Produce the value of <code>expr2</code> if the value of <code>expr1</code> is not zero, the value of <code>expr3</code>, otherwise.</p></li><li><p>The precedence of <code>?:</code> operator is less than <code>||</code>.</p></li><li><p>Often used in return statements.</p></li><li><p>Common in macro definitions.</p></li></ol><h2>Boolean Values</h2><pre><code>_Bool flag;</code></pre><ol><li><p>An integer type but can only be assigned either 0 or 1.</p></li><li><p>Any nonzero value assigned to a <code>_Bool</code> makes the variable be assigned 1.</p></li><li><p>The macros defined in the <code>stdbool.h</code> header file makes the boolean easy to use.</p></li></ol><pre><code>#include &lt;stdbool.h&gt;\n\nbool flag; // Identical to _Bool flag;\nflag = true; // Same as flag = 1;\nflag = false; // Same as flag = 0;</code></pre><h1>3.3 The <code>switch</code> Statement</h1><pre><code>switch (expr) {\n    case const_expr:\n        statements\n    ...\n    case const_expr:\n        statements\n    default:\n        statements\n}</code></pre><ol><li><p>An alternative for a cascaded <code>if</code> statement that compares an expression to a series of values.</p></li><li><p>Often faster than <code>if</code> statements.</p></li><li><p><code>expr</code> must be an integer expression.</p></li><li><p>Characters (<code>char</code>) are treated as integers in C, thus, can also be compared in <code>switch</code> statement.</p></li><li><p>The <code>const_expr</code> can not contain variables and function calls.</p></li><li><p>The <code>const_expr</code> must evaluate to an integer.</p></li><li><p>No braces are required after <code>case</code>.</p></li><li><p>Each group of <code>statements</code> normally ends by <code>break</code>.</p><ul><li><p>The order of <code>case</code>s, even <code>default</code>, does not matter.</p></li></ul></li><li><p>Duplicate <code>case</code> are not allowed.</p></li><li><p>Several case labels may precede a group of statements.</p></li></ol><pre><code>switch (expr) {\n    case 1:\n    case 2:\n    case 3:\n        statements\n}</code></pre><ol start=\"11\"><li><p>The <code>default</code> is not required.</p></li></ol><h2><code>break</code> Statement</h2><ol><li><p>A <code>break</code> in a <code>switch</code> statement makes the control pass to the statement next to the <code>switch</code> statement.</p></li><li><p>Without a <code>break</code>, the control will flow into the next <code>case</code>.</p></li></ol>",
    "videoUrl": " https://www.youtube.com/embed/q4wPvGasdQA,https://www.youtube.com/embed/p8gQggrjFwM,https://www.youtube.com/embed/iBdpPElg8uk",
    "makeUpTime": "2022-10-05T16:00:00.000Z",
    "notification": {
        "makeUpTime": "Gr5u2_5xvgjtX3AIlEgl"
    },
    "startTime": "2022-09-21T16:00:00.000Z",
    "dueTime": "2022-10-12T16:00:00.000Z",
    "sections": [],
    "type": "Homework",
    "index": "Lec03",
    "title": "Control Structures"
}