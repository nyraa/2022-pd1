{
    "review": "<h2><strong>12.1 Dynamic Memory Allocation</strong></h2><h3><strong>Memory Allocation Functions</strong></h3><ul><li><p>The <code>&lt;stdlib.h&gt;</code> header declares three memory allocation functions which return void pointers (<code>void *</code> ) to allocated space or return <code>null pointers</code> if allocation is failed:</p><ul><li><p><code>malloc</code> allocates a block of size bytes but <strong>doesn’t initialize it</strong>.</p><pre><code>void *malloc(size_t size);</code></pre></li><li><p><code>calloc</code> allocates an array with <code>nmemb</code> elements, each of which is <code>size</code> bytes long, and <strong>clears it</strong>.</p><pre><code>void *calloc(size_t nmemb, size_t size);</code></pre></li><li><p><code>realloc</code> <strong>resizes</strong> a block (where <code>ptr</code> points to) to a new <code>size</code> size.</p><pre><code>void *realloc(void *ptr, size_t size);</code></pre></li></ul></li><li><p><code>malloc</code> and the other memory allocation functions obtain memory blocks from a memory pool known as the heap.</p></li><li><p>Calling these functions too often or asking them for large blocks of memory can exhaust the heap, causing the functions to return a null pointer.</p></li></ul><h3><strong>Null Pointers</strong></h3><ul><li><p>A <code>null pointer</code> is a special value that can be distinguished from all valid pointers.</p></li><li><p><code>NULL</code> is a macro (defined in various library headers) that represents the <code>null pointer</code>.</p></li></ul><h2><strong>12.2 Dynamically Allocated Strings</strong></h2><ul><li><p>By allocating strings dynamically, we can postpone the decision of how much space to use until the program is running.</p><ul><li><p>A call of <code>malloc</code> that allocates memory for a string of <code>n</code> characters.</p></li><li><p>Each character requires one byte of memory;</p></li><li><p>Adding 1 to <code>n</code> leaves room for the <code>null character</code>.</p></li></ul><pre><code>char * p;\np = malloc(n + 1);</code></pre></li></ul><h2><strong>12.3 Dynamically Allocated Arrays</strong></h2><ul><li><p>The close relationship between arrays and pointers makes a dynamically allocated array as easy to use as an ordinary array.</p><ul><li><p>We’ll first declare a pointer variable:</p><pre><code>int *a;</code></pre></li><li><p>Once the value of <code>n</code> is known, the program can call <code>malloc</code> to allocate space for the array:</p><pre><code>a = malloc(n * sizeof(int));</code></pre></li><li><p>We can now ignore the fact that a is a pointer and use it instead as an array name, thanks to the relationship between arrays and pointers in C.</p></li></ul></li></ul><h2><strong>12.4 Deallocating Memory</strong></h2><ul><li><p>Each C program is responsible for recycling its own garbage by calling the <code>free</code> function to <strong>release unneeded memory</strong>.</p><pre><code>void free(void *ptr);\n</code></pre></li><li><p>When the block is freed, all the pointers are left dangling.</p></li></ul>",
    "videoUrl": "https://www.youtube.com/embed/lGwL9N5f5oM,https://www.youtube.com/embed/bQom7U6Fx-A,https://www.youtube.com/embed/KEsQN_mFRdw,https://www.youtube.com/embed/7UhcyHFd6GQ",
    "makeUpTime": "2022-12-21T16:00:00.000Z",
    "notification": {
        "makeUpTime": "eYlUaPlr9O9UbcrkHLmX"
    },
    "startTime": "2022-12-07T16:00:00.000Z",
    "dueTime": "2022-12-28T16:00:00.000Z",
    "sections": [],
    "type": "Homework",
    "index": "Lec12",
    "title": "Dynamic Memory Management"
}