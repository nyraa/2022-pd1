{
    "review": "<h1>4.1 Integer Types</h1><h2>Signed &amp; Unsigned Integers</h2><ol><li><p> The leftmost bit of a <strong>signed</strong> integer, known as <strong>sign bit</strong>, indicates the sign of the integer.</p><ul><li><p>0 for positive</p></li><li><p>1 for negative</p></li></ul></li><li><p>An integer whose leftmost bit is considered part of number's magnitude is an <strong>unsigned integer</strong>.</p><ul><li><p>primarily useful for systems programming and low-level, machine-dependent applications.</p></li></ul></li><li><p>Integer variables are <strong>signed</strong> by default.</p></li><li><p>The <code>signed</code> and <code>unsigned</code> specifier could be combined with <code>int</code> to form different integer types.</p></li><li><p>An <code>int</code> variable is usually 32 bits, but may be 16 bits on other CPUs (e.g. Arduino, Raspberry PI, etc).</p></li></ol><h2>Long &amp; Short Integers</h2><ol><li><p>The specifiers <code>long</code> and <code>short</code> are used to define integer variables with different size.</p><ul><li><p>Long integers <strong>may</strong> have more bits than ordinary integers.</p></li><li><p>Short integers <strong>may</strong> have fewer bits than ordinary integers.</p></li></ul></li><li><p>The specifiers <code>long</code>, <code>short</code>, <code>signed</code> and <code>unsigned</code> could be used together. The order of specifiers does not matter, the <code>int</code> could be dropped as well.</p></li><li><p>Modern computers use <strong>two's complement</strong>, adding one to one's complement, to represent negative integer values.</p><ul><li><p>e.g. An 8-bit integer 116 (0111 0100) has one's complement (1000 1011) and two's complement (1000 1100)</p></li></ul></li><li><p>The range of values represented by each integer type is machine dependent but with certain restrictions:</p><ul><li><p>C standard requires that <code>short int</code>, <code>int</code>, and <code>long int</code> must each cover a certain minimum range of values.</p></li><li><p><code>int</code> <strong>must not</strong> be shorter than <code>short int</code>, and <code>long int</code> <strong>must not</strong> be shorter than <code>int</code>.</p></li></ul></li><li><p>The smallest and the largest values of each integer type could be found at <code>limits.h</code> which are defined as macros.</p></li><li><p>C99 provides two additional standard integer types, <code>long long int</code> and <code>unsigned long long int</code>. Both types require to be at least 64 bits wide.</p></li></ol><h2>Integer Constants</h2><ol><li><p>Integer constants are allowed to be written in the following format:</p><ul><li><p><strong>Decimal</strong> (base 10): contains digits between 0 to 9, but <strong>must not begin with a 0</strong>.</p></li><li><p><strong>Octal</strong> (base 8): containa only digits between 0 and 7, and <strong>must begin with a 0</strong>.</p></li><li><p><strong>Hexdecimal</strong> (base 16):  contains digits between 0 and 9 and letters between a(A) and f(F), and <strong>always begin with 0x</strong>.</p></li></ul></li><li><p>Some postfixes could be append to an integer constant to force compiler treats the constant as specific integer type:</p><ul><li><p>l (or L): <code>long int</code></p></li><li><p>ll (or LL): <code>long long int</code></p></li><li><p>u (or U): <code>unsigned int</code></p></li></ul></li></ol><h2>Integer Overflow</h2><ol><li><p>The result of arithmetic operations may be too large to represent, thus, overflow occurs.</p></li><li><p>The behavior when integer overflow occurs depends on the integer type:</p><ul><li><p><strong>signed</strong>: the program’s behavior is <strong>undefined</strong>.</p></li><li><p><strong>unsigned</strong>: the result will be <strong>the correct answer modulo 2n</strong>, where n is the number of bits used to store the result.</p></li></ul></li></ol><h2>Reading &amp; Writing Integers</h2><ol><li><p>Different conversion specifiers are required for different integer types:</p><ul><li><p><code>%u</code>, <code>%o</code> and <code>%x</code>: reads/writes an unsigned integer in base 10, 8 and 16, respectively.</p></li><li><p><code>%hd</code>, <code>%hu</code>, <code>%ho</code> and <code>%hx</code>: are for <code>short</code> integer.</p></li><li><p><code>%ld</code>, <code>%lu</code>, <code>%lo</code> and <code>%lx</code>: are for <code>long</code> integer.</p></li><li><p><code>%lld</code>, <code>%llu</code>, <code>%llo</code> and <code>%llx</code>: are for <code>long long</code> integer.</p></li></ul></li></ol><h1>4.2 Floating Types</h1><ol><li><p>C provides three floating types: <code>float</code>, <code>double</code> and <code>long double</code>.</p></li><li><p>Most modern computers follow the specifications in [IEEE Standard 754](<a rel=\"noopener noreferrer nofollow\" href=\"https://en.wikipedia.org/wiki/IEEE_754)\">https://en.wikipedia.org/wiki/IEEE_754)</a> (also known as IEC 60559).</p></li></ol><h2>The IEEE Floating-Point Standard</h2><ol><li><p>Two primary formats for floating-point numbers: <strong>single precision</strong> (32 bits) and <strong>double precision</strong> (64 bits).</p></li><li><p>Numbers are stored in a form of <strong>scientific notation</strong>, with each number having a <strong>sign</strong>, an <strong>exponent</strong>, and a <strong>fraction</strong>, the length of each part are defined as follows:</p><ul><li><p><strong>Single precision</strong>: 1 bit for sign, 8 bits for exponent, and 23 bits for fraction.</p></li><li><p><strong>Double precision</strong>: 1 bit for sign, 11 bits for exponent, and 52 bits for fraction.</p></li></ul></li></ol><h3>Meaning of Each Part</h3><ol><li><p>Sign: 0 for positive, while 1 for negative</p></li><li><p>Exponent:</p><ul><li><p>Bias 127 for single precision, while bias 1023 for double precision.</p></li><li><p>All zeros and all ones are reserved for special cases:</p></li><li><p><strong>All-zero</strong> exponent with <strong>all-zero</strong> fraction: Zero.</p></li><li><p><strong>All-zero</strong> exponent with <strong>non-zero</strong> fraction: Subnormal number.</p></li><li><p><strong>All-one</strong> exponent with <strong>all-zero</strong> fraction: Infinity.</p></li><li><p><strong>All-one</strong> exponent with <strong>non-zero</strong> fraction: NaN (Not a Number).</p></li><li><p>Numbers with exponent other than the cases mentioned above: Normal number.</p></li></ul></li><li><p>For a normal number, there is a leading (invisible) bit in front of the fraction part.</p></li><li><p>The characteristics of the floating types could be found in the header <code>float.h</code>.</p></li></ol><h2>Floating Constants</h2><ol><li><p>A floating constant must contain a decimal point and/or an exponent which indicates the <strong>power of 10</strong> by which the number is to be scaled.</p></li><li><p>An exponent must be preceded by the letter E (or e).</p></li><li><p>An optional <code>+</code> or <code>-</code> may appear after the E (or e).</p></li><li><p>Floating constants are stored as double-precision numbers, by default.</p></li><li><p>A letter F (or f) at the end of a floating constant indicates that the single precision is desired.</p></li><li><p>Put a letter L (or l) at the end to declare a <code>long double</code> constant.</p></li></ol><h2>Reading &amp; Writing Floating-Point Types</h2><ol><li><p>Three conversion specifications, <code>%e</code>, <code>%f</code> and <code>%g</code>, are used for reading and writing single-precision floating-numbers.</p></li><li><p>Put the letter <code>l</code> in front of the conversions to read a <code>double</code>.</p><ul><li><p>Use <code>l</code> only in a scanf format string, not a printf string.</p></li><li><p>In a printf format string, the conversions can be used to write either <code>float</code> or <code>double</code> values.</p></li></ul></li><li><p>Put the letter <code>L</code> in front of the conversions to  read or write a value of type <code>long double</code>.</p></li></ol><h1>4.3 Character Types</h1><ol><li><p>The values of type <code>char</code> may vary from one computer to another, since different machines may have different underlying character sets.</p></li><li><p>Today’s most popular character set is ASCII, a 7-bit code capable of representing 128 characters.</p></li><li><p>ASCII is often extended to a 256-character (8 bits) code known as Latin-1.</p></li><li><p>A variable of type <code>char</code> can be assigned any single character.</p><ul><li><p>Character constants are enclosed in <strong>single quotes</strong>.</p></li></ul></li><li><p>C treats characters as <strong>small integers</strong>.</p></li><li><p>When a character appears in a computation, C uses its integer value.</p></li><li><p>C allows the use of the words <code>signed</code> and <code>unsigned</code> to modify <code>char</code>.</p></li></ol><h2>Escape Sequences</h2><ol><li><p>A way to represent characters that are not visible or not able to be entered from keyboard.</p></li><li><p>There are two kind of escepe sequences:</p><ol><li><p><strong>Character escape</strong>: Handy, but they don’t exist for all nonprinting ASCII characters.</p></li><li><p><strong>Numeric escape</strong>: Could be used to represent any character with its <strong>octal</strong> or <strong>hexdecimal</strong> value.</p><ul><li><p><strong>Octal escape sequence</strong>: consists of the <code>\\</code> character followed by an octal number with at most three digits.</p></li><li><p><strong>Hexadecimal escape sequence</strong>: consists of \\x followed by a hexadecimal number.</p></li></ul></li></ol></li><li><p>Following are some common escape sequences:</p><ul><li><p>New line: <code>\\n</code></p></li><li><p>Tab: <code>\\t</code></p></li><li><p>Backslash: <code>\\\\</code></p></li><li><p>Single quote: <code>\\'</code></p></li><li><p>Double quote: <code>\\\"</code></p></li></ul></li></ol><h2>Character-Handling Functions</h2><ol><li><p>C library provides a set of useful functions that keep developers away from machine-specific underlying character sets.</p></li><li><p>The functions are defined in the header <code>ctypes.h</code>.</p></li></ol><h2>Reading &amp; Writing Characters</h2><h3>With <code>scanf</code> &amp; <code>printf</code></h3><ol><li><p>Use <code>%c</code> conversion specification to read/write single characters.</p></li><li><p>The white-space characters are not skipped by <code>scanf</code> by default.</p></li><li><p>Use space in the format string of <code>scanf</code> forces it to skip white space.</p></li></ol><h3>With <code>getchar</code> &amp; <code>putchar</code></h3><ol><li><p>Alternative to <code>scanf</code> and <code>printf</code> for single character input and output.</p></li><li><p>Save execution time.</p></li><li><p><code>putchar</code> writes a character.</p></li><li><p><code>getchar</code> reads a character.</p></li><li><p><code>getchar</code> returns an <code>int</code> value rather than a <code>char</code> value.</p></li><li><p><code>getchar</code> does not skip white-space characters.</p></li><li><p>Be careful when mixing <code>getchar</code> and <code>scanf</code>, since <code>scanf</code> has a tendency to leave behind characters that it has “peeked” at but not read.</p></li></ol>",
    "videoUrl": "https://www.youtube.com/embed/DNRUXnzO_fU,https://www.youtube.com/embed/GvybrTbxLrY,https://www.youtube.com/embed/nSWvHr_x2fQ",
    "makeUpTime": "2022-10-19T16:00:00.000Z",
    "notification": {
        "makeUpTime": "4gdzB-hLmsO4Y5oaEdoL"
    },
    "startTime": "2022-10-05T16:00:00.000Z",
    "dueTime": "2022-10-26T16:00:00.000Z",
    "sections": [],
    "type": "Homework",
    "index": "Lec04",
    "title": "Data Types"
}